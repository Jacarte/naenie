import os
import sys
import subprocess
import shutil
import re


import SimpleHTTPServer, BaseHTTPServer
import SocketServer
import threading
import time
import urllib2

import re

from json import loads, dumps


import numpy as np
import matplotlib.pyplot as plt

def getNgramAt(s, i, n):
    return s[i: n + i]

def getNgramSet(s, n):

    result = []

    for i in range(len(s) - n + 1):
        result.append(" ".join(map(lambda x: x.__str__(), getNgramAt(s, i, n))))

    return set(result)

def getDistance(set1, set2, comparisson):

    return 1 - len(set1 & set2)/1.0/comparisson(set1, set2)

def getSimilarityMatrix(sequences, n, comparisson):

    return [[ getDistance(
        getNgramSet(s1, n),
        getNgramSet(s2, n),
        comparisson
    ) for s2 in sequences ] for s1 in sequences]



class HTTPServer(BaseHTTPServer.HTTPServer):

    _continue = True

    def serve_until_shutdown(self):
        while self._continue:
            self.handle_request()

    def shutdown(self):
        self._continue = False
        # We fire a last request at the server in order to take it out of the
        # while loop in `self.serve_until_shutdown`.
        try:
            urllib2.urlopen(
                'http://%s:%s/' % (self.server_name, self.server_port))
        except urllib2.URLError:
            # If the server is already shut down, we receive a socket error,
            # which we ignore.
            pass
        self.server_close()

class SilentRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    def log_message(self, format, *args):
        pass


class HTTPServerLayer(object):

    host = 'localhost'

    def setUp(self, port):
        self.server = None
        self.port = port
        self.start_server()

    def start_server(self):
        self.server = HTTPServer((self.host, self.port), SimpleHTTPServer.SimpleHTTPRequestHandler)
        self.server_thread = threading.Thread(
            target=self.server.serve_until_shutdown)
        self.server_thread.daemon = True
        self.server_thread.start()
        # Kludge: Wait a little as it sometimes takes a while to get the server
        # started.
        time.sleep(0.25)

    def stop_server(self):
        if self.server is None:
            return
        self.server.shutdown()
        self.server_thread.join()

    def tearDown(self):
        self.stop_server()

def processByteCode(code):



    pattern = "((\d|a|b|c|d|e|f)(\d|a|b|c|d|e|f)? )+"
    regex = re.compile(pattern)
    lines = code.split("\n")
    newLines = []

    addressPattern = '0x(\w+) @'
    addressRegex = re.compile(addressPattern)

    allowed = [
        'Constant pool',
        'Handler Table',
        '[generated bytecode for function:',
        'Parameter count',
        'Frame size',
        'Register count'
    ]

    startAddress = -1
    for i in range(len(lines)):
        line = lines[i]

        if any(map(lambda st: line.startswith(st), allowed)):
            newLines.append(line)
        else:
            index = 0
            while index < len(line):
                c = line[index]
                if not ':' in line:
                    print line
                    raise Exception("No line")
                if c == ':': # start the hex block

                    
                    if startAddress == -1:
                        
                        for i in addressRegex.finditer(line):
                            startAddress = int('0x' + i.group(1), 16)
                            break
                    
                    # normalizing address space
                    for i in addressRegex.finditer(line):
                        # if len > 2: jump instruction
                        address = int('0x' + i.group(1), 16) - startAddress
                        line = line.replace(i.group(1), 'some-address')


                    trimmed = line[index + 3:]
                    
                    #print regex.match(trimmed)
                    
                    trimmed = re.sub(pattern, "", trimmed).strip()
                    
                    newLines.append(trimmed)

                    break
                index += 1
    
    return "\n".join(newLines)

def main():


    cases = [
        #'md5',
        #'sudoku',
        #'zip',
        #'mandelbrot',
        #'nested',
        #'qs',
        'sha256'
    ]


    outputDir = 'out'
    for case in cases:

        dirs = os.listdir("out/%s.js"%(case))
        previous = os.getcwd()
        os.chdir("out/%s.js"%(case))

        dirs = filter(None, dirs)
        
        for dirIndex in range(len(dirs)):
            
            d = dirs[dirIndex]
            print dirIndex, len(dirs)

            fullPath = d#'%s/%s.js/%s'%(outputDir,case, d)

            print fullPath
            if not os.path.isdir(fullPath):
                continue
            # moving results
            # shutil.copytree('out', '%s/%s'%(outDir, case))

            # Running chrome cpu profiling


            #web_dir = os.path.join(os.path.dirname(__file__), 'web')
            previous = os.getcwd()
            os.chdir(fullPath)


            PORT = 8010

            server = HTTPServerLayer()
            server.setUp(PORT)

            print "Serving at port", PORT

            #server.start_server()

            print "Launching chrome..."

            mutProcess = subprocess.Popen([
                "/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --no-default-browser-check -user-data-dir=. --js-flags='--print-bytecode' http://localhost:8010/mutation.html & sleep 20;kill $!"
            ],shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            out, err = mutProcess.communicate()
            if err:
                print err
                
            open('mutation.bytecode.txt', 'w').write(processByteCode(out))

            
            mutProcess = subprocess.Popen([
                "/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --no-default-browser-check -user-data-dir=. --js-flags='--print-bytecode' http://localhost:8010/original.html & sleep 20;kill $!"
            ],shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


            out, err = mutProcess.communicate()
            if err:
                print err
                
            open('original.bytecode.txt', 'w').write(processByteCode(out))
            #print(origProcess.stdout)

            server.stop_server()


            #if len(trace) > 0:
            #    traces.append(trace)

            print(previous)
            os.chdir(previous)
        


        os.chdir(previous)

if __name__ == "__main__":
    main()

    
    #processSamples('out/mandelbrot.js/mutated13/profile-original.cpuprofile', 'Fuxuhuuooi', 'mandelbrot')

    #print(processByteCode(open("/Users/javiercabrera/Documents/Develop/WJMachine/out/sha256.js/mutated9/mutation.bytecode.bck.txt", 'r').read()))

