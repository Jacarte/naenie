<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>JS to WASM diversification machine (Naenie proof of concept)</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="js-to-wasm-diversification-machine-naenie-proof-of-concept">JS to WASM diversification machine (Naenie proof of concept)</h1>
<p>Naenie (<em>Many</em> in high valyrian words) tries to generate valid code mutations for JavaScript code using calls between WASM and JS as the mutation operator.</p>
<p><img src="docs/imgs/workflow.png" alt="Workflow"></p>
<p>Taking a JavaScript input file we can obtain the abstract syntax tree (AST) for it. Babel parser output an AST structure base on () spec. Basically, this tool extends those nodes with extra information. First, we analyze the static information from the JavaScript code like literal numbers, strings, booleans, etc. After that, we evaluate an instrumented version of the input code with some provided code to explore the script execution, resolving types in nodes evaluation. Later, the subtrees that can be translated to a Web Assembly Text (<strong>WAT</strong>) function are detected. The final step is to generate Web assembly binary code (<strong>WASM</strong>) and validate it.</p>
<p>The final output is a JavaScript file with its WASM complement.</p>
<p>Also, we implement a &quot;sandbox&quot; wrapper to test the generated code in a browser or node with some workload with the two implementations: the original one and the mutated one.</p>
<p>Basically, we have three inputs for the tool:</p>
<ol>
<li>The file to be mutated</li>
<li>The coverage script to evaluate de input script finding the maximum coverage</li>
<li>The workload script to evaluate the mutation against the original one.</li>
</ol>
<p>And two outputs:</p>
<ol>
<li>The mutated javascript code who calls WASM code to complement it</li>
<li>The complement WASM code</li>
</ol>
<p><img src="docs/imgs/result2.png" alt="Example"></p>
<h2 id="target-subtrees">Target subtrees</h2>
<p>The objective of this tool is to find subtrees in the script AST and then substitute them for a equivalent call to WASM code. Due to JavaScript dynamic behavior, we are focusing to arithmetic expression up to date.</p>
<h2 id="parametrization">Parametrization</h2>
<p>We defined three principal parameters: min-size (min subtree size to replace), max-size (max subtree size to replace) and probability-threshold ( [0, 1] probability to translate the subtree ).</p>
<p>The preliminary analysis of the tools testing shows a overhead invocating WASM functions.</p>
<h2 id="why-is-coverage-script-needed">Why is coverage script needed?</h2>
<p>The main reason is to ensure that the arithmetic subtree return numeric values indeed (boolean values are mapped as int32 values, 0 and 1), watching for &quot;large&quot; integers and &quot;large&quot; floats in runtime evaluation to create a correct mapping between them and the WASM numeric types.</p>
<p>If one operator in the arithmetic subtree (always binary subtree) cannot be accessed from the WASM context then this subtree is passed to the translated subtree as a function parameter, for example:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> a  = <span class="hljs-number">1</span> + a[<span class="hljs-number">0</span>]
</div></code></pre>
<p>Is translated to</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> a = ww.Wrapper(<span class="hljs-number">1</span>, a[<span class="hljs-number">0</span>])
</div></code></pre>
<pre><code><div>(function $Wrapper(param i32, param i32)
    get_local 0
    get_local 1
    i32.add)
</div></code></pre>
<p><em>We need to care about boolean operations shortcut too</em>
<em>//https://github.com/dcodeIO/webassembly/issues/26 Javascript does not support int64 function signature for WASM up to date</em></p>
<p>This tool its extending right now, to cover calls from WASM code to the JavaScript one. Trying to cover a complete JavaScript translation.</p>
<h1 id="how-to-use-it">How to use it?</h1>
<p>You can use two options to run the mutator:</p>
<ol>
<li>Using ts-node: <code>npm run ts src/main.dev.ts &lt;target&gt; &lt;coverage&gt; &lt;workload&gt;</code></li>
<li>Compile the complete library to a ES6 JavaScript library <code>npm run compile</code> and then execute the compiled code <code>node dist/naenie.js</code></li>
</ol>
<p><strong>Help output</strong></p>
<pre><code><div>-v                          output the version number
-t --target &lt;target&gt;        Target script
-c --coverage &lt;coverage&gt;    Coverage script
-w --workload &lt;workload&gt;    Workload script
-m --minumum &lt;minimum&gt;      Minimum tree size to translate
-M --maximum &lt;maximum&gt;      Maximum tree size to translate
-u --threshold &lt;threshold&gt;  Probability to translate subtree
-s --sandbox &lt;sandbox&gt;      Sandbox wrapper: 'node' or 'browser'
-h, --help                  output usage information
</div></code></pre>
<!--

### Translation

- TODO

### Sandbox
- Node sandbox
- Browser sandbox

## Output

- Output structure

## Profiling

- Browser
  - Launch local server on output directory
  - Chrome basic
  - Firefox basic
  
- Node with perf in linux

-->
<h2 id="results">Results</h2>
<p>Run <code>python tests/run_all.py</code> to execute the complete pipeline to mutate and profile target test scripts.</p>
<h3 id="automated-testing-with-chrome">Automated testing with Chrome</h3>
<p>We open and profile the both, mutated and original codes, with the workload script. This process is done in an automated way using the 'chrome-remote-interface' and the 'chrome-launcher' node packages. The profiling output file protocol is showed below:</p>
<pre><code class="language-ts"><div>{
    nodes: {
        id: <span class="hljs-built_in">number</span>,
        callFrame: {
            <span class="hljs-string">"functionName"</span>: <span class="hljs-built_in">string</span>,
            scriptId: <span class="hljs-built_in">string</span>,
            url: <span class="hljs-built_in">string</span>,
            lineNumber: <span class="hljs-built_in">number</span>,
            columnNumber: <span class="hljs-built_in">number</span>
        },
        hitCount: <span class="hljs-built_in">number</span>,
        children: <span class="hljs-built_in">number</span>[],
        positionTicks?: {
            line: <span class="hljs-built_in">number</span>,
            ticks: <span class="hljs-built_in">number</span>
        }[]
    }[],

    startTime: <span class="hljs-built_in">number</span>,
    endTime: <span class="hljs-built_in">number</span>,
    samples: <span class="hljs-built_in">number</span>[],
    timeDeltas: <span class="hljs-built_in">number</span>[]
}
</div></code></pre>
<p>From <strong><a href="https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile">https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile</a></strong></p>
<p><img src="docs/imgs/profiling_data.png" alt="https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile"></p>
<h2 id="mandelbrot-call-graph-example">Mandelbrot call graph example</h2>
<h2 id="finding-execution-trace">Finding execution trace</h2>
<ol>
<li>Find target function</li>
<li>Start at the first index with the function id just after one lesser value</li>
<li>Stop at the next one value less than function id</li>
</ol>
<ul>
<li>
<p>Test subjects</p>
<ul>
<li>quicksort (DONE)</li>
<li>zip  (DONE)</li>
<li>sudoku (DONE)</li>
<li>md5 (In process)</li>
<li>rsa (In process)</li>
<li>rc4 (In process)</li>
<li>canny (In process)</li>
<li>lcs (In process)</li>
<li>laguerre (In process)</li>
<li>linreg (In process)</li>
<li>mandelbrot (DONE)</li>
<li>sha256 (DONE)</li>
</ul>
</li>
<li>
<p>Mutation output</p>
<ul>
<li>Garbage collection calls as noise</li>
</ul>
</li>
<li>
<p>Mutated candidate performance and overhead</p>
<ul>
<li>Execution time</li>
<li>Memory</li>
<li>CPU</li>
</ul>
</li>
</ul>

    </body>
    </html>